---
title: "Milestone 6"
author: "Diego Martinez"
date: "4/3/2020"
output: bookdown::pdf_document2
bibliography: [bibliography.bib]



---


This is my pdf document for milestone 6 of Gov 1006 Final Project. Please refer to the Github repository for my entire project.^[[All analysis for this paper is available on my Github Reposotory](https://github.com/diegomartinez1221/gov_1006_replication)] I am replicating Why Friends and Neighbors? Explaining the Electoral Appeal of Local Roots ^[[Replication Paper](https://www.journals.uchicago.edu/doi/abs/10.1086/703131)] by Rosie Campbell, Philip Cowley, Nick Vivyan, Markus Wagner. They seek to answer how politicians with local roots have greater appeal in elections. 

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)

# With the time constrictions due to swithcing papers, I was not able to comment
# all of the replication code. I did comment areas I did need to make changes.

library(bookdown)
library(dplyr)
library(tinytex)
library(gt)
library(gtsummary)
library(stargazer)
library(knitr)
library(tidyverse)
library(devtools)
library(ggplot2)
library(sandwich)
library(lmtest)
library(stargazer)
library(cowplot)
library(cobalt)
library(xtable)
library(devtools)
library(margins)
library(car)
library(foreign)
library(rms)
library(reshape2)
library(plyr)
library(arm)
```


# Mileston 5 

##Paper Overview 

My replication paper will be looking at Rosie Campbell, Philip Cowley, Nick Vivyan, Markus Wagner's paper, "Why Friends and Neighbors? Explaining the Electoral Appeal of Local Roots" published in The Journal of Politics. The paper studies the phenomon of why local politicians seem to gain more electoral support in elections. Whereas the "friends and neigbors" effect has previously been found to arise when there is a lack of information in regard to policy, only thing voters know is they are local, this articles purpose is to explain the "direct effect of local roots on voter evaluations of a politician" [@campbell_cowley_vivyan_wagner_2019]. It is the authors belief that voters "use local roots as a low-cost cue for making inferences about a politician’s “behavioral localism" (an elected official acting in the interest of their [@campbell_cowley_vivyan_wagner_2019]. Their hypothesis is that the power of local roots in decision making for voters is weakened when voters are moer informed about the behavioral localism. The authors use survey experiments of made up candidates running for sets in Parliament in the UK rather than performing an observational study on real elections to isolate the effects of local roots. 

Study 1 used a vignette experiment to more generally test whether the presence of information on behavioral localism impacts the effects of local roots while Study 2 gives people a more wide array of information to test whether having greater knowledge of each candidate elimates the effects of local roots. Study 1 presented a hypothetical election between two candidates and they tested how varying levels of behavioral localism information interacts with being a local candidate. The modeled this with a least squares regression model and their focus was on the interaction term (being a local candidate and having information). The results were that the presence of behavioral information whether positive or negative does lessen the friends and neighbors effect. However, they found being local candidate still positively impacts voters and the authors proceeded to study 2. Since study 2 posseses much more and much more varied information on the candidates in question. They analyze the average marginal component effect (AMCE), the probability of why a candidate is being chosen broken down by each indivual component of their profile (ex. being local, political party, gender). Even here with so much more information, they found the AMCE for being local was positive and one of the most prominent compared to others.

Thus, voters use local roots as an important factor in candidate selection when there is a lack of any other information. However, what is more interesting is that local roots are still a notable factor even when voters have a wider and more in-depth knowledge of each candidate.



## Beautiful Graphic 


```{r, m5 graphic}

# necessary packages. I needed to detach plyr because even though the author
# uses it, it interferes with my use of dplr

detach(package:plyr)
library(tidyverse)
library(dplyr)

# reading in the data for study 1 

d <- readRDS("./friends_neighbors_replication/study1data.rds")

d%>%
  
  # grouping by both treatments variables, creating six groups to find the
  # average score for each candidate. These follows the same groupings used in
  # the article.
  
  group_by(localtreat, behtreat)%>%
  summarise(avg_phil_score = round(mean(philscore), digits = 2),
         avg_nick_score = round(mean(nickscore), digits = 2))%>%
  
  # right now the scores are in two different columns. Pivoting to bring these
  # two together so that I may compare then in a graphic. 
  
  pivot_longer(cols = ends_with("score"), 
               names_to = "candidate",
               values_to = "scores")%>%
  
  # many of the variables names are are currently appreviated or just not in a
  # pretty form for the grap. I use recode to change the variables to better
  # labels in the graph
  
  mutate(candidate = fct_recode(candidate, "Phil" = "avg_phil_score", "Nick" = "avg_nick_score"), 
         behtreat = fct_recode(behtreat, "Constituent focus" = "Const. focus", "National focus" = "Westmin. focus", "No Information" = "No behavioural info"))%>%

  # creating the plot. Chose columns just to be able to see the differences
  # between phil and nick as well as be able to see between the various facets
  
  ggplot() + geom_col(aes(y = scores, x = candidate, fill = candidate), width = 0.5)+
  
  # I use a grid to create a 3x2 graphic for the various treatment combinations. 
  
  facet_grid(behtreat~localtreat) + 
  
  # adding informative labels and titles 
  
  labs(title = "Average Candidate Scores Across Various Treatment Groups",
       subtitle = "Nick Having Local Roots Increases His Average Score Across All Levels of Behavioral\n Localism", x = "Candidate", y = "Scores", caption = "Footnote: Very similar to Figure 1 from `Why Friends and Neighbors? Explaining the Electoral Appeal of Local\n Roots`. I use the raw scores instead of Nick minus Phil for my graphic; however the same results can be seen.\nThe facets of local root vs. not local roots and the behavioral information are all refering to changes to Nick, not Phil,\n and these are the differences in treatment groups") + 
  
  # there is no need for the legend so I take it out to save room. 
  
  theme(legend.position = "none")
```

# Mileston 6 Paper Extensions 

The authors were very thorough in their analysis including a lengthy appendix with a lot of other things that were tested that were not highlighted prominently in the main article. However, I do believe there are a of interesting paths to follow regard to extensions. The authors in their discussion and conclusion provide a lengthy list of questions and extension that arise from their own analysis. However, most of this does involve trying with trying to explain the local roots effect that was out of the scope of their analysis : " What might account for the local roots effects that we have observed but that are left un-explained by the particular mechanisms considered in this article?" [@campbell_cowley_vivyan_wagner_2019]. They go on to speak about theories as well as experiments that should be cared out, including questions and frameworks for experiments with real elections to view how their results play out in an actual race. However, they do not mention much at all about the shortcomings of their analysis (not that there is necessarily any, the analysis was very thorough) and all of these proposed extensions are outside the scope of Gov 1006. My extensions will be focused on the data and experiments they used and will consist of subsetting the data to view how their results apply to various subgroups of the population. 

For study 1, the authors in one of the appendices performed balance and randomization checks to insure that there is a "distributional balance of four respondent characteristics – gender, age, education and social grade, all measured pretreatment – across the six treatment groups created in the experiment" [@campbell_cowley_vivyan_wagner_2019]. Since "None of the differences in proportions across treatment groups are bigger than 10% and only a small number are greater than 5%" [campbell_cowley_vivyan_wagner_2019], I believe this presents an excellent opportunity to dive deeper into if the "friends and neighbors" effect is stronger for one subset of the population than others (ex. males vs. females, older vs. younger). I hypothesis that there may in fact be some interesting differences especially in regard to age. For example, do the younger people in the study, who may not be as engaged in politics or care how they are represented in Parliament, more often vote for the candidate with local roots. Or even on the opposite side of the spectrum, do the elder people in the study who have been engrained in their community and care about their representation vote for the person who will concerned more with the wants and needs of the people than his/her personal political views. I could do a lot more analysis such as this with gender as well and the other personal information included about the people surveyed. 

I am unsure about specific extensions for study 2. Following along the same lines of the extensions I proposed for study 1, I can run a logistic regression model to find the probability a person votes for each type of candidate profile using voter information such as gender, age, education level of the voter themselves. 


# Replication Appendix 

I recreate all the important graphs and tables as specified by Milestone 6. 
```{r, table 1 setup}
# Replication code for Study 1 in 
# Campbell, R., Cowley, P., Vivyan, N & Wagner, M. 
# 'Why friends and neighbors? Explaining the electoral appeal of local roots'.
# Journal of Politics


### Load in Study 1 data

d <- readRDS("./friends_neighbors_replication/study1data.rds")


### Table 2

# The authors created various different models of the data. These models are
# displayed in table 1 of the paper and model 4 is used throughout the paper.
# The authors same the results of the models and the errors in separate objects
# so that they can all be called togethered to create a stargazer table

m1 <- lm(nickminusphil ~ localtreat*behtreatsimple, data = d)

se1 <- sqrt(diag(vcovHC(m1)))

m2 <- lm(nickminusphil ~ localtreat*behtreatsimple +
           gender + agegrp + socgrade + qual
         , data = d)
se2 <- sqrt(diag(vcovHC(m2)))

m3 <- lm(nickminusphil ~ localtreat*behtreat, data = d)
se3 <- sqrt(diag(vcovHC(m3)))

m4 <- lm(nickminusphil ~ localtreat*behtreat +
           gender + agegrp + socgrade + qual
         , data = d)
se4 <- sqrt(diag(vcovHC(m4)))
```

## Table 1
(also fulfills reproducing a table needed for Milestone 5)
```{r table 1, results="asis", message=FALSE, comment=FALSE}
## Output to table

# I needed to change/add many things to the original to get a more similar table
# to the one that apppars in the paper. 

stargazer(header = FALSE, 
          
          # calling all the linear models and errors created in teh previous chunk. 
          
          mget(paste0("m",1:4)),
          se = mget(paste0("se",1:4)),
          
          # latex was the only kind I could get to output in the pdf. It was
          # orignally type html
          
          type = "latex",
          
          # needed to add the title myself as well. 
          
          title = " Relative Ratings of MP Nick by Local Roots and Behavioral Information Treatments in Study", 
          
          # Could not find another way to add the two separations visible in
          # the table model. I needed to use these latex commands combined with
          # column.separate.
          
          column.labels=c('\\shortstack{Conditioning Effect of Any Behavioral\\\\ Localism Information}', '\\shortstack{Separate Conditioning Effects for\\\\ High and Low Behavioral Localism}'),
          column.separate = c(2,2),
          
          # both of these are needed to erase the dependent variable 
          
          dep.var.labels.include = FALSE,
          dep.var.caption = "",
          #intercept.bottom = FALSE, intercept.top = TRUE,
          keep.stat = c("n", "rsq", "adj.rsq"),
          omit = "socgrade|agegrp|gender|qual",
          order = c("Constant", "^localtreatLocal roots$", 
                    "^behtreatsimpleBehavioural info$", 
                    "^behtreatConst. focus$", 
                    "^behtreatWestmin. focus$",
                    "^localtreatLocal roots:behtreatsimpleBehavioural info$",
                    "^localtreatLocal roots:behtreatConst. focus$",
                    "^localtreatLocal roots:behtreatWestmin. focus$"
          ),
          add.lines = list(c("Controls for voter characteristics?", 
                             rep(c("No","Yes"), 2))),
          covariate.labels = c("Intercept", "Local roots", "Behavioral localism information",
                               "Behavioral localism: High (vs. no info)",
                               "Behavioral localism: Low (vs. no info)",
                               "Local roots X Behavioral info.", 
                               "Local roots X High behavioral localism",
                               "Local roots X Low behavioral localism"),
          
          # The notes section was not originally included in the replication
          # code. I was able to create something similar using the latex
          # commends, but it is not an exact match
          
       notes.append = FALSE, notes.align = "l",
      notes.label  = "\\multicolumn{5}{l}{\\parbox[t]{\\textwidth}{Note. All models estimated via ordinary least squares. Dependent variable is respondent relative rating of MP Nick (the 0–10 rating of Nick minus that of Philip). Robust standard errors in parentheses. N p 5,203.}}\\\\"
)

```

##Figure 1

```{r figure 1, cache=TRUE}
### Figure 1


### Create useful functions

## Function to get predicted levels for different treatment combinations
predict.rob <- function(object, vcov,newdata){
  tt <- terms(object)
  if(missing(newdata)){ newdata <- x$model }
  else {
    Terms <- delete.response(tt)
    m <- model.frame(Terms, newdata, na.action = na.pass, 
                     xlev = object$xlevels)
    if (!is.null(cl <- attr(Terms, "dataClasses"))) 
      .checkMFClasses(cl, m)
    X <- model.matrix(Terms, m, contrasts.arg = object$contrasts)
    offset <- rep(0, nrow(X))
    if (!is.null(off.num <- attr(tt, "offset"))) 
      for (i in off.num) offset <- offset + eval(attr(tt, 
                                                      "variables")[[i + 1]], newdata)
    if (!is.null(object$call$offset)) 
      offset <- offset + eval(object$call$offset, newdata)
    mmDone <- FALSE
  }
  #m.mat <- model.matrix(x$terms,data=newdata)
  m.coef <- object$coef
  fit <- as.vector(X %*% object$coef)
  se.fit <- sqrt(diag(X%*%vcov%*%t(X)))
  return(list(fit=fit,se.fit=se.fit))
}



## Avg treatment effect of local roots with const and westmihn. info
out <- summary(margins(m4, vcov = vcovHC(m4), 
                       at = list(behtreat = c("No behavioural info", "Const. focus", "Westmin. focus"))))
out <- subset(out, factor == "localtreatLocal roots")
margins.m4 <- out 


## make margins plot
margins.comb <- margins.m4
margins.comb$behtreat.neat <- car:::recode(margins.comb$behtreat, 
                                           '"No behavioural info" = "Behavioral information treatment --\\nNo information (Vignettes 1-2)";
                                           "Westmin. focus" = "Behavioral information treatment --\\nLow behavioral localism (Vignettes 5-6)";
                                           "Const. focus" = "Behavioral information treatment --\\nHigh behavioral localism (Vignettes 3-4)"')
                                           #as.factor.result = TRUE)
margins.comb$behtreat.neat <- factor(sub(" --", ":", margins.comb$behtreat.neat),
                                     levels = c("Behavioral information treatment:\nNo information (Vignettes 1-2)", 
                                                "Behavioral information treatment:\nLow behavioral localism (Vignettes 5-6)",
                                                "Behavioral information treatment:\nHigh behavioral localism (Vignettes 3-4)"
                                     ))
p1 <- ggplot(margins.comb, aes(x = factor, y = AME)) + 
  geom_hline(yintercept = 0, linetype = "dashed", size = 0.5) +
  geom_linerange(aes(x=factor, ymin=lower, ymax=upper), size = 0.6) +
  geom_point(size = 3.5, shape = 21, fill = "white") +
  labs(x = "", y = "") + 
  coord_flip() +
  facet_wrap( ~ behtreat.neat, ncol = 1) + 
  theme_bw() +
  theme(legend.position = "bottom") +
  theme(axis.ticks.y = element_blank(), axis.text.y = element_blank()) + 
  ggtitle("(b) Effect of MP local roots \ntreatment") 

## predlevels for m4
newdf <- data.frame(expand.grid(localtreat = factor(c("No local roots", "Local roots"), 
                                                    levels = levels(d$localtreat)),
                                behtreat = factor(levels(d$behtreat), levels = levels(d$behtreat))
),
gender = factor(levels(d$gender)[which.max(table(d$gender))], 
                levels = levels(d$gender)),
agegrp = factor(levels(d$agegrp)[which.max(table(d$agegrp))], 
                levels = levels(d$agegrp)),
socgrade = factor(levels(d$socgrade)[which.max(table(d$socgrade))], 
                  levels = levels(d$socgrade)),
qual = factor(levels(d$qual)[which.max(table(d$qual))], 
              levels = levels(d$qual))
)
preds <- predict.rob(m4, vcov = vcovHC(m4), newdata = newdf)
newdf$yhat <- preds$fit
newdf$se.yhat <- preds$se.fit
newdf$lo <- newdf$yhat - (1.96*newdf$se.yhat)
newdf$hi <- newdf$yhat + (1.96*newdf$se.yhat)
predlevels.m4 <- newdf


## make predlevels plot
predlevels.comb <- predlevels.m4
predlevels.comb$behtreat.neat <- car:::recode(predlevels.comb$behtreat, 
                                              '"No behavioural info" = "Behavioral information treatment --\\nNo information (Vignettes 1-2)";
                                              "Westmin. focus" = "Behavioral information treatment --\\nLow behavioral localism (Vignettes 5-6)";
                                              "Const. focus" = "Behavioral information treatment --\\nHigh behavioral localism (Vignettes 3-4)"')
                                              #as.factor.result = TRUE)
predlevels.comb$behtreat.neat <- factor(sub(" --", ":", predlevels.comb$behtreat.neat),
                                        levels = c("Behavioral information treatment:\nNo information (Vignettes 1-2)", 
                                                   "Behavioral information treatment:\nLow behavioral localism (Vignettes 5-6)",
                                                   "Behavioral information treatment:\nHigh behavioral localism (Vignettes 3-4)"
                                        ))

p2 <- ggplot(predlevels.comb, aes(x = localtreat, y = yhat)) + 
  geom_hline(yintercept = 0, linetype = "dashed", size = 0.5) +
  geom_linerange(aes(x=localtreat, ymin=lo, ymax=hi), size = 0.6) +
  geom_point(size = 3.5, shape = 21, fill = "white") +
  labs(x = "", y = "") + 
  coord_flip() +
  facet_wrap( ~ behtreat.neat, ncol = 1) + 
  theme_bw() +
  theme(legend.position = "bottom") + 
  labs(title = "(a) Predicted relative rating")


## Now combine aspects of above plots into 3 x 2 plot, I changed to make them both 1,1
pcomb <- plot_grid(p2, p1, align = "h", rel_widths = c(1.0,0.80))

?plot_grid
```

```{r}
pcomb
```

##Figure 2
```{r figure 2 functions}
add.top <- function(df, new.level){
  to.add <- data.frame(mean = c(NA,NA, 0), ci.lo = c(NA,NA, 0), ci.hi = c(NA,NA, 0),
                       category = rep("", 3), attribute = rep(df$attribute[1],3),
                       level = c("", " ", new.level))
  return(rbind(to.add, df))
}
add.justify <- function(df){
  df$left.justify <- rep(0, nrow(df))
  df$left.justify[2] <- 1
  return(df)
}


## Function to get regression-based AMCE estimates for each attribute level using 
## OLS estimator with clustered SEs (Hainmueller, Hopkins and Yammamoto 2014)

get.amcetab <- function(data, variables, J = 2){    
  Nvar <- length(variables)
  amce.list <- vector("list", length = Nvar)
  
  for(i in 1:Nvar){ # get AMCE for each variable attribute
    fmla <- as.formula(paste("mp.preferred ~ ",variables[i], sep = ""))
    model <- ols(fmla, data = data, x = T, y = T) 
    # NOTE: The data for the model has to have no NAs on any model variables 
    # for the robcov(cluster()) function to work 
    model.clus <- robcov(model, cluster = data$ID, method = "efron")
    coef <- model.clus$coef[names(model.clus$coef)!="Intercept"]
    se.clus <- sqrt(diag(model.clus$var))
    se.clus <- se.clus[names(se.clus)!="Intercept"]       
    sub.tab <- data.frame("AMCE" = coef, 
                          "ci.lo" = coef - (1.96*se.clus),
                          "ci.hi" = coef + (1.96*se.clus),
                          "cluster.se" = se.clus)
    sub.tab$category <- names(coef)
    sub.tab <- cbind(sub.tab, colsplit(sub.tab$category, "=", c("attribute","level")))
    sub.tab$level <- as.character(sub.tab$level)    
    row.names(sub.tab) <- NULL
    # add in gaps and baselines
    to.add <- data.frame(AMCE = c(NA,NA, 0), ci.lo = c(NA,NA, 0), ci.hi = c(NA,NA, 0),
                         cluster.se = c(NA,NA, 0),
                         category = rep("", 3), attribute = rep(sub.tab$attribute[1],3),
                         level = c("", " ", "baseline"))
    amce.list [[i]] <- rbind(to.add, sub.tab)
  } 
  amce.tab <- do.call("rbind", amce.list)
  # re-make initial labels column
  amce.tab$category <- paste(amce.tab$attribute, amce.tab$level, sep = ": ")
  # make this into ordered factor
  amce.tab$category <- factor(amce.tab$category, levels = rev(amce.tab$category), order =T)    
  
  return(amce.tab)
}

## Function that calls get.amcetab for multiple predictors and combines results

amce.tab <- function(data, variables, multi = F, same.party = F){
  # data must be a single data frame or a list of data frames (if multi = T)
  # with named elements
  # Also relies on specific ordering of explanatory variables
  if(multi == T & same.party == F){
    amce.tab.list <- list(NA, length = length(data))
    for(i in 1:length(data)){
      tmp <- get.amcetab(data[[i]], variables = variables)
      tmp$set <- rep(names(data)[i], nrow(tmp))
      amce.tab.list[[i]] <- tmp
    }
    amce.tab <- do.call("rbind",amce.tab.list)
    amce.tab$set <- factor(amce.tab$set)
    return(amce.tab)
  }
  if(multi == T & same.party == T){
    amce.tab.list <- list(NA, length = length(data))
    for(i in 1:length(data)){
      vars <- if(grepl("same party", names(data)[i])==T|grepl("Same Party", names(data)[i])==T) variables[2:length(variables)] else variables
      tmp <- get.amcetab(data[[i]], variables = vars)
      tmp$set <- rep(names(data)[i], nrow(tmp))
      amce.tab.list[[i]] <- tmp
    }
    names(amce.tab.list) <- names(data)
    diff.party <- amce.tab.list[grepl("same party", names(amce.tab.list))==F&
                                  grepl("Same Party", names(amce.tab.list))==F]
    same.party <- amce.tab.list[grepl("same party", names(amce.tab.list))==T |
                                  grepl("Same Party", names(amce.tab.list))==T]
    to.add <- data.frame(AMCE = rep(NA, 4), ci.lo = rep(NA, 4), ci.hi =  rep(NA, 4),
                         cluster.se =  rep(NA, 4),
                         category =  diff.party[[1]]$category[1:4], 
                         attribute =  diff.party[[1]]$attribute[1:4], 
                         level = diff.party[[1]]$level[1:4],
                         set = rep(NA, 4))
    for(i in 1:length(data)){                     
      if(grepl("same party", names(data)[i])==T|grepl("Same Party", names(data)[i])==T){
        amce.tab.list[[i]] <- rbind(to.add,amce.tab.list[[i]])
        amce.tab.list[[i]]$set[1:4] <-  amce.tab.list[[i]]$set[5:8]
      }
      else amce.tab.list[[i]] <- amce.tab.list[[i]]
    }     
    amce.tab <- do.call("rbind",amce.tab.list)
    amce.tab$set <- factor(amce.tab$set)
    return(amce.tab)
  } 
  if(multi == F)   {
    get.amcetab(data, variables)
  }
  
}


```


```{r figure 2 graph, message=FALSE, warning=FALSE}
### Load in Study 2 data 

long.dat <- readRDS("./friends_neighbors_replication/study2data_long.rds")
wide.dat <- readRDS("./friends_neighbors_replication/study2data_wide.rds")


### Create labels for plotting

# for full results
labels.full <- rev(expression(
  "", italic("Party & position (baseline = Labour left-wing)"), "Labour centre", "Conservative centre", "Conservative right-wing",
  "", italic("Local roots (baseline = lives elsewhere)"),"5 years in area", "20 years in area", "Grew up and lives in area", 
  "", italic("Constituency work (baseline = 1 day)"), "2 days", "3 days", "4 days",
  "", italic("Main policy influence (baseline = party)"), "constituents' views","own personal views",
  "", italic("Policy interests (baseline = economy and tax)"), "education and health",
  "", italic("MP sex (baseline = female)"), "male"))

# for analysis of local roots only
labels.sub <- expression("Grew up and lives in area", "20 years in area", "5 years in area", 
                         italic("Local roots (baseline = lives elsewhere)"))


# for x axis
effect.label <- "Change in probability of MP being preferred,\n relative to baseline"





### Figure 3: AMCEs for all attributes

res <- amce.tab(data = long.dat, 
                variables = c("mp.partypos", "mp.localroots", "mp.const", "mp.influence", "mp.policy", "mp.gender")
                , multi = F)
res$category <- factor(as.character(res$category), levels = rev(as.character(res$category)), order =T)
#write.csv(res, "amce-all.csv")# write results to csv file

# Full plot for all attributes
res <- res[2:nrow(res),] # chop off top empty layer
res <- subset(res, level != "baseline")# remove artificial 'baseline' rows
labels <- labels.full
ggplot(res, aes(x = category, y = AMCE, color = attribute)) + 
  geom_hline(yintercept = 0, linetype = "dashed", size = 0.5) +
  geom_pointrange(aes(ymin = ci.lo, ymax = ci.hi), size = 0.75) + 
  labs(y = effect.label, x = "") + 
  coord_flip() + 
  theme_bw() + 
  theme(axis.text = element_text(colour = "black")) +
  theme(legend.position = "none") +
  theme(text = element_text(size = 15)) +
  theme(axis.ticks.y = element_blank(), axis.text.y = element_text(hjust = 1), # remove ticks and justify
        axis.title.x = element_text(size = 13, vjust = 0)) + 
  scale_x_discrete(labels=labels)

```

## Replication: What I Achieved and What I Did Not 

I was able to replicate all the code of the paper. There were some errors based on updating of packages. I had the most difficulty with trying to replicate the stargazer table. The code by itself did not have the note at the bottom nor the column headers. I was not able to replicate the table exaclty, however, I was ablle to figure out how to make it as similar as possible. I did so manipulating the Latex of the stargazer output. 

# Citations 

The data and code for this replication is from Dataverse [@campbell_cowley_vivyan_wagner_2018]. I used the stargazer package to replicate tables [@stargazer] and I follow reccomendations made by Gary King for replication [@king]. I use many techniques from the Gov 1006 textbook "Regression and Other Stories" [@RAOS] as well.

#Bibliography